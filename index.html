<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>AR Model Move Rotate Zoom</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>
<style>
  body { margin:0; overflow:hidden; }
</style>
</head>
<body>

<a-scene embedded
         arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">

  <!-- ⭐ 独自パターンマーカー -->
  <a-marker type="pattern" url="pattern-marker.patt">

    <!-- モデル -->
    <a-entity id="model"
              gltf-model="./gyu.glb"
              position="0 0 0"
              scale="0.2 0.2 0.2"
              rotation="0 0 0"></a-entity>

  </a-marker>

  <a-entity camera></a-entity>
</a-scene>

<script>
const model = document.getElementById("model");

/* ------------------------------------
   1本指 → 上下左右移動
------------------------------------- */
let startX = null;
let startY = null;
let currentPos = { x: 0, y: 0, z: 0 };

document.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
  }
});

document.addEventListener("touchmove", e => {
  if (e.touches.length === 1 && startX !== null) {
    const deltaX = e.touches[0].clientX - startX;
    const deltaY = e.touches[0].clientY - startY;

    const moveX = currentPos.x + deltaX * 0.002;
    const moveY = currentPos.y - deltaY * 0.002;

    model.setAttribute("position", `${moveX} ${moveY} ${currentPos.z}`);
  }
});

document.addEventListener("touchend", e => {
  if (startX !== null) {
    const pos = model.getAttribute("position");
    currentPos = { x: pos.x, y: pos.y, z: pos.z };
    startX = null;
    startY = null;
  }
});


/* ------------------------------------
   2本指 → 回転
------------------------------------- */
let lastAngle = null;
let currentRotationY = 0;

function getAngle(e) {
  const dx = e.touches[1].clientX - e.touches[0].clientX;
  const dy = e.touches[1].clientY - e.touches[0].clientY;
  return Math.atan2(dy, dx);
}

document.addEventListener("touchstart", e => {
  if (e.touches.length === 2) {
    lastAngle = getAngle(e);
  }
});

document.addEventListener("touchmove", e => {
  if (e.touches.length === 2 && lastAngle !== null) {
    const angle = getAngle(e);
    const diff = angle - lastAngle;

    currentRotationY += diff * 180 / Math.PI;
    model.setAttribute("rotation", `0 ${currentRotationY} 0`);

    lastAngle = angle;
  }
});

document.addEventListener("touchend", e => {
  if (e.touches.length < 2) {
    lastAngle = null;
  }
});


/* ------------------------------------
   2本指ピンチ → 拡大縮小
------------------------------------- */
let initialDistance = null;
let currentScale = 0.2;   // 初期スケールに合わせること

function getDistance(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.hypot(dx, dy);
}

document.addEventListener("touchstart", e => {
  if (e.touches.length === 2) {
    initialDistance = getDistance(e);
  }
});

document.addEventListener("touchmove", e => {
  if (e.touches.length === 2 && initialDistance) {
    const newDistance = getDistance(e);
    const scaleFactor = newDistance / initialDistance;

    const newScale = Math.min(Math.max(currentScale * scaleFactor, 0.05), 2);

    model.setAttribute("scale", `${newScale} ${newScale} ${newScale}`);
  }
});

document.addEventListener("touchend", e => {
  if (initialDistance && e.touches.length < 2) {
    // 拡大縮小を確定
    currentScale = parseFloat(model.getAttribute("scale").x);
    initialDistance = null;
  }
});
</script>

</body>
</html>
