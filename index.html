<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>AR PLAY 3Dモデル 最小版</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  a-scene { width:100vw; height:100vh; position:absolute; top:0; left:0; }
  #info { position: fixed; top:10px; left:10px; color:white; font-family:sans-serif;
          background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; z-index:999; }
  #toggle { position: fixed; bottom:50px; left:10px; padding:8px 14px; border:none; border-radius:8px;
            font-size:16px; color:white; cursor:pointer; background:#007bff; z-index:1000; }
</style>
</head>
<body>

<div id="info">現在地を取得中...</div>
<button id="toggle">テストモード中（切替）</button>

<a-scene embedded
         arjs="sourceType: webcam; debugUIEnabled: false; resolution: 640"
         renderer="antialias: true; precision: highp; logarithmicDepthBuffer: true; preserveDrawingBuffer: true">

  <a-light type="ambient" intensity="1.0"></a-light>
  <a-light type="directional" intensity="0.7" position="0 5 5"></a-light>

  <a-entity id="model" visible="false"
            gltf-model="./gyu.glb"
            material="metalness:0; roughness:1; toneMapped:false"
            dracoDecoderPath="https://www.gstatic.com/draco/versioned/decoders/1.5.6/"
            position="0 0 -12" scale="0.5 0.5 0.5" rotation="0 0 0">
  </a-entity>

  <a-camera id="camera"></a-camera>
</a-scene>

<script>
const TARGET = { name:"大代地区公民館", lat:38.29667, lon:141.01084, message:"大代地区公民館にようこそ！" };
const RANGE = 100;
let testMode = true;

const info = document.getElementById("info");
const model = document.getElementById("model");
const toggleBtn = document.getElementById("toggle");
const camera = document.getElementById("camera");

// 距離計算
function distance(lat1, lon1, lat2, lon2){
  const R=6371e3, φ1=lat1*Math.PI/180, φ2=lat2*Math.PI/180, Δφ=(lat2-lat1)*Math.PI/180, Δλ=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// 現在地チェック
function checkLocation(pos){
  const { latitude, longitude } = pos.coords;
  const dist = distance(latitude, longitude, TARGET.lat, TARGET.lon);
  info.textContent = `現在地: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
  if(dist < RANGE){
    model.setAttribute("visible", "true");
    info.textContent = `${TARGET.message}（距離${dist.toFixed(1)}m）`;
  } else model.setAttribute("visible", "false");
}

// 追跡開始
function startTracking(){
  if(testMode) checkLocation({ coords:{ latitude:TARGET.lat, longitude:TARGET.lon } });
  else if(navigator.geolocation) navigator.geolocation.watchPosition(checkLocation, ()=>info.textContent="位置情報が取得できません");
  else info.textContent="位置情報がサポートされていません";
}

// テストモード切替
toggleBtn.onclick = ()=>{
  testMode = !testMode;
  toggleBtn.textContent = testMode ? "テストモード中（切替）" : "実際の位置情報モード中（切替）";
  model.setAttribute("visible","false");
  startTracking();
};

// モデル読み込み時に縦伸び防止
model.addEventListener('model-loaded', () => {
  const scale = 0.5;
  model.object3D.scale.set(scale, scale, scale);
});

// 指1本でX/Z移動
let moving=false, lastTouch=null;
document.addEventListener("touchstart", e=>{
  if(e.touches.length===1 && model.getAttribute("visible")==="true"){
    moving=true;
    lastTouch={x:e.touches[0].clientX, y:e.touches[0].clientY};
  }
});
document.addEventListener("touchmove", e=>{
  if(moving && e.touches.length===1){
    const dx=(e.touches[0].clientX-lastTouch.x)/200;
    const dz=(e.touches[0].clientY-lastTouch.y)/200;
    const moveVector = new THREE.Vector3(-dx,0,-dz);
    moveVector.applyQuaternion(camera.object3D.quaternion);
    model.object3D.position.add(moveVector);
    lastTouch={x:e.touches[0].clientX, y:e.touches[0].clientY};
  }
});
document.addEventListener("touchend", ()=>{ moving=false; });

// 指2本でY回転＋ピンチ拡大縮小
let twoFinger={initialDistance:null, startTouches:null, startScale:0.5, startRot:null};
document.addEventListener("touchstart", e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    twoFinger.initialDistance=Math.hypot(dx,dy);
    twoFinger.startTouches=[{x:e.touches[0].clientX,y:e.touches[0].clientY},{x:e.touches[1].clientX,y:e.touches[1].clientY}];
    twoFinger.startScale=model.object3D.scale.x;
    twoFinger.startRot=model.object3D.rotation.y;
  }
});
document.addEventListener("touchmove", e=>{
  if(e.touches.length===2 && twoFinger.initialDistance){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const distance=Math.hypot(dx,dy);
    const newScale=Math.min(Math.max(twoFinger.startScale*(distance/twoFinger.initialDistance),0.1),3);
    model.object3D.scale.set(newScale,newScale,newScale);

    const midX=(e.touches[0].clientX+e.touches[1].clientX)/2;
    const startMidX=(twoFinger.startTouches[0].x+twoFinger.startTouches[1].x)/2;
    model.object3D.rotation.y=twoFinger.startRot+(midX-startMidX)*0.01;
  }
});
document.addEventListener("touchend", e=>{ if(e.touches.length<2) twoFinger.initialDistance=null; });

startTracking();
</script>
</body>
</html>
