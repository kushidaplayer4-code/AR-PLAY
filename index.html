<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>AR PLAY デモ</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  #info { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; z-index:999; }
  button { position:absolute; bottom:10px; padding:8px 14px; border:none; border-radius:8px; font-size:16px; color:white; cursor:pointer; z-index:1000; }
  #reset { left:10px; background:#ff5722; }
</style>
</head>
<body>
<div id="info">モデル操作中...</div>
<button id="reset">🔄 リセット</button>

<a-scene embedded renderer="preserveDrawingBuffer: true;">
  <a-entity id="model" gltf-model="./gyu.glb" scale="0.5 0.5 0.5" position="0 0 -12" rotation="0 0 0"></a-entity>
  <a-camera position="0 1.6 0"></a-camera>
</a-scene>

<script>
const info = document.getElementById("info");
const model = document.getElementById("model");
const resetBtn = document.getElementById("reset");

// 初期値
const INIT_POS = { x:0, y:0, z:-12 };
const INIT_ROT = { x:0, y:0, z:0 };
const INIT_SCALE = 0.5;

// リセット
resetBtn.onclick = () => {
  model.setAttribute("position", `${INIT_POS.x} ${INIT_POS.y} ${INIT_POS.z}`);
  model.setAttribute("rotation", `${INIT_ROT.x} ${INIT_ROT.y} ${INIT_ROT.z}`);
  model.setAttribute("scale", `${INIT_SCALE} ${INIT_SCALE} ${INIT_SCALE}`);
  currentScale = INIT_SCALE;
  info.textContent = "モデルを初期状態にリセットしました";
};

// ピンチでスケール
let initialDistance = null, currentScale = INIT_SCALE;

// ドラッグで回転/移動
let isDragging = false;
let previousTouch = null;

document.addEventListener("touchstart", e => {
  if(e.touches.length === 2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    initialDistance = Math.hypot(dx, dy);
  } else if(e.touches.length === 1){
    isDragging = true;
    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

document.addEventListener("touchmove", e => {
  if(e.touches.length === 2 && initialDistance){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const scaleFactor = Math.hypot(dx, dy) / initialDistance;
    const newScale = Math.min(Math.max(currentScale * scaleFactor, 0.1), 5);
    model.setAttribute("scale", `${newScale} ${newScale} ${newScale}`);
  } else if(e.touches.length === 1 && isDragging){
    const dx = e.touches[0].clientX - previousTouch.x;
    const dy = e.touches[0].clientY - previousTouch.y;

    // Y軸回転
    const rotation = model.getAttribute("rotation");
    model.setAttribute("rotation", `0 ${rotation.y + dx*0.5} 0`);

    // X/Z 移動
    const pos = model.getAttribute("position");
    const moveFactor = 0.01;
    model.setAttribute("position", `${pos.x + dx*moveFactor} ${pos.y} ${pos.z + dy*moveFactor}`);

    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
});

document.addEventListener("touchend", e => {
  if(e.touches.length < 2 && initialDistance){
    currentScale = parseFloat(model.getAttribute("scale").x);
    initialDistance = null;
  }
  if(e.touches.length === 0){
    isDragging = false;
    previousTouch = null;
  }
});
</script>
</body>
</html>
