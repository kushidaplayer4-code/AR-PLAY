<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>AR 安定版（マーカーなし・iPhone対応）</title>

<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>

<style>
  html, body {
    margin:0; padding:0; width:100%; height:100%; background:#000;
    touch-action: none;
  }
  a-scene { width:100vw; height:100vh; }
  #info { position:fixed; top:10px; left:10px; color:white; background:rgba(0,0,0,0.5);
    padding:8px 12px; border-radius:8px; font-family:sans-serif; z-index:999; }
  #reset { position:fixed; bottom:50px; left:10px; padding:8px 14px; border:none;
    border-radius:8px; font-size:16px; color:white; cursor:pointer; background:#28a745; z-index:1000; }

  /* iPhone Safariのvideo安定化 */
  video {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    object-fit: cover !important;
    z-index: -1 !important;
  }
</style>
</head>
<body>

<div id="info">指でモデル操作できます</div>
<button id="reset">リセット</button>

<a-scene embedded
  arjs="sourceType: webcam; debugUIEnabled: false; maxDetectionRate: 30; sourceWidth: 640; sourceHeight: 480;"
>
  <a-light type="ambient" intensity="1.0"></a-light>
  <a-light type="directional" intensity="0.8" position="1 2 1"></a-light>

  <a-entity id="model" gltf-model="./gyu.glb"
    position="0 0 -12" scale="0.5 0.5 0.5" rotation="0 0 0"></a-entity>

  <a-camera id="camera"></a-camera>
</a-scene>

<script>
const model = document.getElementById("model");
const camera = document.getElementById("camera");
const resetBtn = document.getElementById("reset");

// 初期状態
const initialState = {
  position: model.object3D.position.clone(),
  rotationY: model.object3D.rotation.y,
  scale: model.object3D.scale.x
};
let targetPosition = initialState.position.clone();
let targetRotationY = initialState.rotationY;
let targetScale = initialState.scale;

// リセットボタン
resetBtn.onclick = () => {
  targetPosition.copy(initialState.position);
  targetRotationY = initialState.rotationY;
  targetScale = initialState.scale;
};

// 1本指でXZ移動
let moving=false,lastTouch=null;
document.addEventListener("touchstart", e => {
  if(e.touches.length===1){
    moving=true;
    lastTouch={x:e.touches[0].clientX, y:e.touches[0].clientY};
  }
});
document.addEventListener("touchmove", e => {
  if(moving && e.touches.length===1){
    const dx=(e.touches[0].clientX - lastTouch.x)/200;
    const dz=(e.touches[0].clientY - lastTouch.y)/200;
    const move=new THREE.Vector3(-dx,0,-dz).applyQuaternion(camera.object3D.quaternion);
    targetPosition.add(move);
    lastTouch={x:e.touches[0].clientX, y:e.touches[0].clientY};
  }
});
document.addEventListener("touchend", () => moving=false);

// 2本指で拡大縮小＋Y軸回転
let twoFinger={initialDistance:null, startScale:0.5, startRot:0, startMidX:0};
document.addEventListener("touchstart", e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX - e.touches[1].clientX;
    const dy=e.touches[0].clientY - e.touches[1].clientY;
    twoFinger.initialDistance = Math.hypot(dx,dy);
    twoFinger.startScale = targetScale;
    twoFinger.startRot = targetRotationY;
    twoFinger.startMidX = (e.touches[0].clientX + e.touches[1].clientX)/2;
  }
});
document.addEventListener("touchmove", e=>{
  if(e.touches.length===2 && twoFinger.initialDistance){
    const dx=e.touches[0].clientX - e.touches[1].clientX;
    const dy=e.touches[0].clientY - e.touches[1].clientY;
    const distance=Math.hypot(dx,dy);
    targetScale=Math.min(Math.max(twoFinger.startScale*(distance/twoFinger.initialDistance),0.1),3);
    const midX=(e.touches[0].clientX + e.touches[1].clientX)/2;
    targetRotationY = twoFinger.startRot + (midX - twoFinger.startMidX)*0.01;
  }
});
document.addEventListener("touchend", e=>{
  if(e.touches.length<2) twoFinger.initialDistance=null;
});

// 滑らかに反映
AFRAME.registerComponent('smooth-update',{
  tick:function(){
    model.object3D.position.lerp(targetPosition,0.1);
    model.object3D.rotation.y += (targetRotationY - model.object3D.rotation.y)*0.1;
    const s=model.object3D.scale.x + (targetScale - model.object3D.scale.x)*0.1;
    model.object3D.scale.set(s,s,s);
  }
});
model.setAttribute('smooth-update','');
</script>

</body>
</html>
